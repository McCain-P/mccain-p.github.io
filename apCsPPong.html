<html>
	<head>
		<title>
			Pong
		</title>
		<style>
			body {
				background-color: RGB(0,0,0);
			}
			body * {
				margin: 0;
				padding: 0;
				cursor: default;
			}
			body button, body input {
				cursor: pointer;
			}
			body *::selection {
				color: RGB(0,0,0);
				background-color: RGB(255,255,255);
			}
			body *:focus {
				outline: none;
			}
			p, h1, h2, button, label, input {
				color: RGB(255,255,255);
				font-family: "Arial", sans-serif;
			}
			.framed {
				background-color: RGB(0,0,0);
				border: 0.5vw solid RGB(255,255,255);
			}
			.framed.thin {
				border-width: 0.25vw;
			}
			#canvas {
				z-index: -1;
				height: 80vh;
				width: 80vh;
				position: fixed;
				top: 10vh;
				left: calc(50vw - 40vh);
			}
			#title {
				z-index: 0;
				height: auto;
				width: auto;
				position: fixed;
				top: 2vh;
				left: 5vw;
				text-align: left;
				font-size: 6vh;
			}
			#configuration {
				z-index: 0;
				height: calc(10vh - 1vw);
				width: 100vw;
				position: fixed;
				bottom: 0;
				left: 0;
				border-top: 0.5vw solid RGB(255,255,255);
			}
			button:hover, input:hover {
				background-color: RGB(64,64,64);
			}
			button:active, input:focus {
				background-color: RGB(32,32,32);
			}
			#configuration > button {
				z-index: 1;
				font-size: 2vw;
				width: 20%;
				height: 80%;
				position: absolute;
				top: 10%;
			}
			#openKeyBindings {
				right: 5%;
			}
			#openScoring {
				right: 30%;
			}
			#openVisuals {
				right: 55%;
			}
			#startStop {
				right: 80%;
			}
			.popup {
				z-index: 2;
				width: 90vh;
				height: 90vh;
				position: fixed;
				top: 5vh;
				left: calc(50vw - 45vh);
			}
			.popup > .popupContent {
				z-index: 2;
				width: 72vh;
				height: 72vh;
				position: absolute;
				top: 9vh;
				left: 9vh;
			}
			.popup * {
				z-index: 3;
			}
			.popup.disabled {
				display: none;
			}
			.popup.enabled {
				display: block;
			}
			.popupClose {
				width: 5%;
				height: 5%;
				position: absolute;
				top: 1.25%;
				left: 1.25%;
				font-size: 3vh;
			}
			.popup.config > .popupContent {
				display: grid;
				grid-template: repeat(auto-fit, 5vh) / 51vh 11vh;
				grid-auto-flow: row;
				grid-gap: 4.5vh 10vh;
				/*place-items: stretch;*/
				place-items: start;
			}
			.popup.config > .popupContent > label, .popup.config > .popupContent > input, .popup.config > .popupContent > button:not(.popupClose) {
				font-size: 4.5vh;
				text-align: left;
				height: 5vh;
			}
			.popup.config > .popupContent > label, .popup.config > .popupContent > .restoreDefaultsButton {
				width: 51vh;
			}
			.popup.config > .popupContent > input {
				width: 11vh;
				font-size: 2vh;
				text-align: center;
			}
			.popup.config > .popupContent > button:not(.popupClose) {
				font-size: 4vh;
			}
			#errorMessage > h2, #errorMessage > p {
				color: RGB(255,0,0);
				margin-left: 5%;
				margin-right: 5%;
			}
			#errorMessageHeader {
				margin-top: 5%;
				margin-bottom: 2.5%;
			}
			#errorMessageBody {
				margin-top: 2.5%;
				margin-bottom: 5%;
			}
			.score {
				font-size: 6vh;
				position: fixed;
				top: 15vh;
				z-index: 0;
			}
			#score0 {
				left: calc(50vw - 35vh);
			}
			#score1 {
				right: calc(50vw - 35vh);
			}
			@keyframes flashingAnimation {
				0% {
					visibility: hidden;
				}
				50% {
					visibility: hidden;
				}
				51% {
					visibility: visible;
				}
				100% {
					visibility: visible;
				}
			}
			.flashing {
				animation: 1s linear 0s infinite normal none running flashingAnimation;
			}
		</style>
	</head>
	<body>
		<h1 id="title">
			Pong
		</h1>
		<p class="score" id="score0">
			0
		</p>
		<p class="score" id="score1">
			0
		</p>
		<canvas class="framed" id="canvas">
		</canvas>
		<div id="configuration">
			<button class="framed thin" id="openKeyBindings">
				Key Bindings
			</button>
			<div class="popup config framed disabled" id="keyBindings">
				<button class="popupClose framed thin" id="closeKeyBindings">
					X
				</button>
				<div class="popupContent">
					<label for="keyPaddle0Up">
						Paddle 0 Up
					</label>
					<input type="text" readonly="true" class="framed thin" id="keyPaddle0Up" data-index="0" value="w">
					</input>
					<label for="keyPaddle0Down">
						Paddle 0 Down
					</label>
					<input type="text" readonly="true" class="framed thin" id="keyPaddle0Down" data-index="1" value="s">
					</input>
					<label for="keyPaddle1Up">
						Paddle 1 Up
					</label>
					<input type="text" readonly="true" class="framed thin" id="keyPaddle1Up" data-index="2" value="ArrowUp">
					</input>
					<label for="keyPaddle1Down">
						Paddle 1 Down
					</label>
					<input type="text" readonly="true" class="framed thin" id="keyPaddle1Down" data-index="3" value="ArrowDown">
					</input>
					<label for="keyStartStop">
						Start/Stop
					</label>
					<input type="text" readonly="true" class="framed thin" id="keyStartStop" data-index="4" value="Space">
					</input>
					<button class="framed thin restoreDefaultsButton" id="restoreDefaultsKeyBindings">
						Restore Defaults
					</button>
				</div>
			</div>
			<button class="framed thin" id="openScoring">
				Scoring
			</button>
			<div class="popup config framed disabled" id="scoring">
				<button class="popupClose framed thin" id="closeScoring">
					X
				</button>
			</div>
			<button class="framed thin" id="openVisuals">
				Visuals
			</button>
			<div class="popup config framed disabled" id="visuals">
				<button class="popupClose framed thin" id="closeVisuals">
					X
				</button>
			</div>
			<button class="framed thin" id="startStop">
				Start
			</button>
		</div>
		<div class="popup framed disabled" id="errorMessage">
			<h2 id="errorMessageHeader">
				An Error Has Occurred:
			</h2>
			<p id="errorMessageBody">
			</p>
		</div>
	</body>
	<script>
		//<game & gui>
		//keyBindings, maxScore, and colors are configuration values
		//keyBindings = {paddle0Up, paddle0Down, paddle1Up, paddle1Down, startStop}
		var keyBindings = ["w", "s", "ArrowUp", "ArrowDown", "Space"];
		var maxScore = 6;
		//colors = {backgroundColor, paddle0Color, paddle1Color, ballColor}
		var colors = ["#000000", "#FFFFFF", "#FFFFFF", "#FFFFFF"];
		//defaultConfigurationValues = {keyBindings, maxScore, colors}
		var defaultConfigurationValues = [["w", "s", "ArrowUp", "ArrowDown", "Space"], 6, ["#000000", "#FFFFFF", "#FFFFFF", "#FFFFFF"]];
		//</game & gui>
		//<game>
		var w = window.innerWidth;
		var h = window.innerHeight;
		var canvas = document.getElementById("canvas");
		canvas.width = w;
		canvas.height = h;
		var c = canvas.getContext("2d");
		c.fillStyle = colors[0];
		c.fillRect(0, 0, w, h);
		/*
		positionSize = {
			{
				{paddle0X, paddle0Y},
				{paddle0W, paddle0H}
			},
			{
				{paddle1X, paddle1Y},
				{paddle1W, paddle1H}
			},
			{
				{ballX, ballY},
				{ballW, ballH}
			}
		}
		*/
		var padding = w / 16;
		var ballR = w / 64;
		positionSize = [
			[
				[padding, (h / 2) - (w / 8)],
				[w / 32, w / 4]
			],
			[
				[w - padding - (w / 32), (h / 2) - (w / 8)],
				[w / 32, w / 4]
			],
			[
				[w / 2, h / 2],
				[2 * ballR, 2 * ballR]
			]
		];
		c.fillStyle = colors[1];
		c.fillRect(positionSize[0][0][0], positionSize[0][0][1], positionSize[0][1][0], positionSize[0][1][1]);
		c.fillStyle = colors[2];
		c.fillRect(positionSize[1][0][0], positionSize[1][0][1], positionSize[1][1][0], positionSize[1][1][1]);
		c.fillStyle = colors[3];
		c.beginPath();
		c.arc(positionSize[2][0][0], positionSize[2][0][1], ballR, 0, 2 * Math.PI);
		c.fill();
		function moveObject(object, x, y, relativePositioning) {
			var objectType = 0;
			switch (object) {
				case 0:
				case 1:
					objectType = 0;
					break;
				case 2:
					objectType = 1;
					break;
				default:
					return undefined;
			};
			c.fillStyle = colors[0];
			//residueCorrectionAmount pixels is added to w and h to account for an "outline residue" that occurs when removing objects by drawing over them with the background color
			var residueCorrectionAmount = 2;
			if (objectType === 0) {
				c.fillRect(positionSize[object][0][0] - residueCorrectionAmount / 2, positionSize[object][0][1] - residueCorrectionAmount / 2, positionSize[object][1][0] + residueCorrectionAmount, positionSize[object][1][1] + residueCorrectionAmount);
			} else {
				c.beginPath();
				c.arc(positionSize[object][0][0], positionSize[object][0][1], positionSize[object][1][0] / 2 + residueCorrectionAmount / 2, 0, 2 * Math.PI);
				c.fill();
			};
			if (relativePositioning) {
				positionSize[object][0][0] += x;
				positionSize[object][0][1] += y;
			} else {
				positionSize[object][0][0] = x;
				positionSize[object][0][1] = y;
			};
			for (var i = 0; i < 2; i++) {
				c.fillStyle = colors[i + 1];
				c.fillRect(positionSize[i][0][0], positionSize[i][0][1], positionSize[i][1][0], positionSize[i][1][1]);
			};
			c.fillStyle = colors[3];
			c.beginPath();
			c.arc(positionSize[2][0][0], positionSize[2][0][1], positionSize[2][1][0] / 2, 0, 2 * Math.PI);
			c.fill();
		};
		var paddleDirection = [0, 0];
		var paddleMovementLoop = [0, 0];
		function paddleMovement(paddle, state, direction) {
			window.clearInterval(paddleMovementLoop[paddle]);
			paddleDirection[paddle] = 0;
			if (state) {
				paddleDirection[paddle] = direction;
				paddleMovementLoop[paddle] = window.setInterval(function() {
					var d0 = ((h / 50) * direction);
					var d = positionSize[paddle][0][1] + d0
					if (d < 0) {
						d0 = -positionSize[paddle][0][1];
					} else if (d + positionSize[paddle][1][1] > h) {
						d0 = h - (positionSize[paddle][0][1] + positionSize[paddle][1][1]);
					};
					moveObject(paddle, 0, d0, true);
				}, 10);
			};
		};
		function errorHandling(errorObject) {
			document.getElementById("errorMessageBody").innerHTML = errorObject.name + ": " + errorObject.message;
			document.getElementById("errorMessage").classList.remove("disabled");
			document.getElementById("errorMessage").classList.add("enabled");
		};
		//scores = {player0, player1}
		scores = [0, 0];
		var gameRunning = false;
		var gameComplete = false;
		var scoreElements = [document.getElementById("score0"), document.getElementById("score1")];
		function startStop(status) {
			if (status && gameComplete) {
				scores = [0, 0];
				for (var i = 0; i < scoreElements.length; i++) {
					scoreElements[i].innerHTML = "0";
					scoreElements[i].classList.remove("flashing");
				};
				moveObject(2, 0, 0, false);
				initializeBall();
				gameComplete = false;
			};
			gameRunning = status;
			if (status) {
				document.getElementById("startStop").innerHTML = "Stop";
			} else {
				paddleMovement(0, false, 0);
				paddleMovement(1, false, 0);
				document.getElementById("startStop").innerHTML = "Start";
			};
		};
		window.addEventListener("keydown", function(e) {
			try {
				if (gameRunning) {
					var key = e.key;
					switch (key) {
						case keyBindings[0]:
		  					paddleMovement(0, true, -1);
		  					break;
		  				case keyBindings[1]:
							paddleMovement(0, true, 1);
							break;
						case keyBindings[2]:
							paddleMovement(1, true, -1);
							break;
						case keyBindings[3]:
							paddleMovement(1, true, 1);
							break;
						default:
							break;
					};
				};
			} catch (errorObject) {
				errorHandling(errorObject);
			};
		});
		window.addEventListener("keyup", function(e) {
			try {
				if (gameRunning) {
					var key = e.key;
					switch(key) {
						case keyBindings[0]:
							paddleMovement(0, false, -1);
							break;
						case keyBindings[1]:
							paddleMovement(0, false, 1);
							break;
						case keyBindings[2]:
							paddleMovement(1, false, -1);
							break;
						case keyBindings[3]:
							paddleMovement(1, false, 1);
							break;
						default:
							break;
					};
				};
			} catch (errorObject) {
				errorHandling(errorObject);
			};
		});
		var audioContext = new AudioContext();
		function playFrequency(fPreset) {
			var f = 0;
			switch (fPreset) {
				case 0:
					f = 110;
					break;
				case 1:
					f = 220;
					break;
				case 2:
					f = 440;
					break;
				default:
					f = fPreset;
					break;
			};
			fHertzTone = audioContext.createOscillator();
			fHertzTone.type = "square";
			fHertzTone.frequency.value = f;
			fHertzTone.start(audioContext.currentTime);
			fHertzTone.stop(audioContext.currentTime + 0.5);
		};
		/*
		function circleRectangleCollision(paddle) {
			var closestHorizontalEdge = 0;
			var closestVerticalEdge = 0;
			var circleRadius = positionSize[2][1][0] / 2;
			//edges = {circleLeftEdge, circleRightEdge, circleTopEdge, circleBottomEdge, paddleLeftEdge, paddleRightEdge, paddleTopEdge, paddleBottomEdge}
			var edges = [positionSize[2][0][0] - circleRadius, positionSize[2][0][0] + circleRadius, positionSize[2][0][1] - circleRadius, positionSize[2][0][1] + circleRadius, positionSize[paddle][0][0], positionSize[paddle][0][0] + positionSize[paddle][1][0], positionSize[paddle][0][1], positionSize[paddle][0][1] + positionSize[paddle][1][1]];
			//closestEdges = {circleHorizontal, circleVertical, rectangleHorizontal, rectangleVertical}
			var closestEdges = [];
			//distances = {horizontalDistance, verticalDistance}
			var distances = [];
			if (edges[1] <= edges[4]) {
				closestEdges[0] = edges[1];
				closestEdges[2] = edges[4];
				distances[0] = Math.abs(closestEdges[0] - closestEdges[2]);
			} else if (edges[0] >= edges[5]) {
				closestEdges[0] = edges[0];
				closestEdges[2] = edges[5];
				distances[0] = Math.abs(closestEdges[0] - closestEdges[2]);
			} else {
				distances[0] = 0;
			};
			if (edges[3] <= edges[6]) {
				closestEdges[1] = edges[3];
				closestEdges[3] = edges[6];
				distances[1] = Math.abs(closestEdges[1] - closestEdges[3]);
			} else if (edges[2] >= edges[7]) {
				closestEdges[1] = edges[2];
				closestEdges[3] = edges[7];
				distances[1] = Math.abs(closestEdges[1] - closestEdges[3]);
			} else {
				distances[1] = 0;
			};
			return circleRadius >= Math.sqrt(Math.pow(distances[0], 2) + Math.pow(distances[1], 2));
		};
		*/
		/*
			paddle = 0 -> paddle 0
			paddle = 1 -> paddle 1
			axis = 0 -> x axis
			axis = 1 -> y axis
		*/
		function circleRectangleCollision() {
			var paddleCollision = [false, false];
			var crcH = positionSize[2][0][0];
			var crcK = positionSize[2][0][1];
			var crcR = positionSize[2][1][0] / 2;
			var crcN = [];
			var crcA = [];
			var crcB = [];
			if () {
				//Paddle 0 right edge
				ballVelocity[0] *= -1;
				ballVelocity[0] += paddleAcceleration;
				paddleCollision[0] = true;
			} else if () {
				//Paddle 1 left edge
				ballVelocity[0] *= -1;
				ballVelocity[0] -= paddleAcceleration;
				paddleCollision[1] = true;
			} else if () {
				//Paddle 0 top edge
				ballVelocity[1] *= -1;
				ballVelocity[1] -= paddleAcceleration;
				paddleCollision[0] = true;
			} else if () {
				//Paddle 0 bottom edge
				ballVelocity[1] *= -1;
				ballVelocity[1] += paddleAcceleration;
				paddleCollision[0] = true;
			} else if () {
				//Paddle 1 top edge
				ballVelocity[1] *= -1;
				ballVelocity[1] -= paddleAcceleration;
				paddleCollision[1] = true;
			} else if () {
				//Paddle 1 bottom edge
				ballVelocity[1] *= -1;
				ballVelocity[1] += paddleAcceleration;
				paddleCollision[1] = true;
			} else if () {
				//Paddle 0 left edge
				ballVelocity[0] *= -1;
				ballVelocity[0] -= paddleAcceleration;
				paddleCollision[0] = true;
			} else if () {
				//Paddle 1 right edge
				ballVelocity[0] *= -1;
				ballVelocity[0] += paddleAcceleration;
				paddleCollision[1] = true;
			};
			if (paddleCollision[0] || paddleCollision[1]) {
				//Any paddle edge
				playFrequency(2);
				if (paddleCollision[0]) {
					//Paddle 0 edges
					ballVelocity[1] += paddleAcceleration * paddleDirection[0];
				} else {
					//Paddle 1 edges
					ballVelocity[1] += paddleAcceleration * paddleDirection[1];
				};
			};
		};
		var ballVelocity = [];
		function initializeBall() {
			moveObject(2, w / 2, h / 2, false);
			//ballVelocity = {x vector, y vector, magnitude, direction (radian angle)}
			ballVelocity = [0, 0, h / 200, Math.random() * 2 * Math.PI];
			ballVelocity[0] = ballVelocity[2] * Math.cos(ballVelocity[3]);
			ballVelocity[1] = ballVelocity[2] * Math.sin(ballVelocity[3]);
		};
		initializeBall();
		function updateScore(player) {
			scores[player]++;
			scoreElements[player].innerHTML = scores[player];
			if (scores[player] === maxScore) {
				gameComplete = true;
				startStop(false);
				scoreElements[player].classList.add("flashing");
			} else {
				initializeBall();
			};
		};
		var paddleAcceleration = h * Math.sqrt(2) / 1600;
		var ballMovement = window.setInterval(function() {
			try {
				if (gameRunning) {
					//Top edge or bottom edge
					if (positionSize[2][0][1] - positionSize[2][1][0] / 2 <= 0 || positionSize[2][0][1] + positionSize[2][1][0] / 2 >= h) {
						playFrequency(1);
						ballVelocity[1] *= -1;
					};
					//{Left edge, right edge}
					var horizontalEdgeCollisions = [positionSize[2][0][0] - positionSize[2][1][0] / 2 <= 0, positionSize[2][0][0] + positionSize[2][1][0] / 2 >= w];
					//Left edge or right edge
					if (horizontalEdgeCollisions[0] || horizontalEdgeCollisions[1]) {
						ballVelocity[0] *= -1;
						playFrequency(0);
						if (horizontalEdgeCollisions[0]) {
							//Left edge
							updateScore(1);
						} else {
							//Right edge
							updateScore(0);
						};
					};
					//{Paddle 0, paddle 1}
					var paddleCollisions = [circleRectangleCollision(0), circleRectangleCollision(1)];
					//Paddle 0 or paddle 1
					if (paddleCollisions[0] || paddleCollisions[1]) {
						ballVelocity[0] *= -1;
						playFrequency(2);
						if (paddleCollisions[0]) {
							//Paddle 0
							ballVelocity[0] += paddleAcceleration;
							ballVelocity[1] += paddleAcceleration * paddleDirection[0];
						} else {
							//Paddle 1
							ballVelocity[0] += -paddleAcceleration;
							ballVelocity[1] += paddleAcceleration * paddleDirection[1];
						};
					};
					moveObject(2, ballVelocity[0], ballVelocity[1], true);
				};
			} catch (errorObject) {
				errorHandling(errorObject);
			};
		}, 10);
		//</game>
		//<gui>
		var openKeyBindings = document.getElementById("openKeyBindings");
		var keyBindingsPopup = document.getElementById("keyBindings");
		var closeKeyBindings = document.getElementById("closeKeyBindings");
		openKeyBindings.addEventListener("click", function() {
			startStop(false);
			keyBindingsPopup.classList.remove("disabled");
			keyBindingsPopup.classList.add("enabled");
		});
		closeKeyBindings.addEventListener("click", function() {
			keyBindingsPopup.classList.remove("enabled");
			keyBindingsPopup.classList.add("disabled");
		});
		var openScoring = document.getElementById("openScoring");
		var scoringPopup = document.getElementById("scoring");
		var closeScoring = document.getElementById("closeScoring");
		openScoring.addEventListener("click", function() {
			startStop(false);
			scoringPopup.classList.remove("disabled");
			scoringPopup.classList.add("enabled");
		});
		closeScoring.addEventListener("click", function() {
			scoringPopup.classList.remove("enabled");
			scoringPopup.classList.add("disabled");
		});
		var openVisuals = document.getElementById("openVisuals");
		var visualsPopup = document.getElementById("visuals");
		var closeVisuals = document.getElementById("closeVisuals");
		openVisuals.addEventListener("click", function() {
			startStop(false);
			visualsPopup.classList.remove("disabled");
			visualsPopup.classList.add("enabled");
		});
		closeVisuals.addEventListener("click", function() {
			visualsPopup.classList.remove("enabled");
			visualsPopup.classList.add("disabled");
		});
		var startStopButton = document.getElementById("startStop");
		startStopButton.addEventListener("click", function() {
			startStop(!gameRunning);
		});
		var keyBindingsOptions = document.getElementById("keyBindings").getElementsByTagName("input");
		var keyBindingsEventListeners = [];
		for (var i = 0; i < keyBindingsOptions.length; i++) {
			keyBindingsOptions[i].addEventListener("focus", function(e) {
				keyBindingsOptions[e.target.dataset.index] = e.target.addEventListener("keydown", function(keyE) {
					keyBindings[keyE.target.dataset.index] = keyE.key;
					keyE.target.value = keyE.key;
				});
			});
			keyBindingsOptions[i].addEventListener("blur", function(e) {
				e.target.removeEventListener("keydown", keyBindingsOptions[e.target.dataset.index]);
			});
		};
		document.getElementById("restoreDefaultsKeyBindings").addEventListener("click", function(e) {
			for (var i = 0; i < keyBindings.length; i++) {
				keyBindings[i] = defaultConfigurationValues[0][i];
				keyBindingsOptions[i].value = defaultConfigurationValues[0][keyBindingsOptions[i].dataset.index]
			};
		});
		//</gui>
	</script>
</html>
