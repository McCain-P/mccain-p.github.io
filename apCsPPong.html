<html>
	<head>
		<title>
			Pong
		</title>
		<style>
			body {
				background-color: RGB(0,0,0);
			}
			body * {
				margin: 0;
				padding: 0;
				cursor: default;
			}
			body button, body input {
				cursor: pointer;
			}
			body *::selection {
				color: RGB(0,0,0);
				background-color: RGB(255,255,255);
			}
			body *:focus {
				outline: none;
			}
			p, h1, h2, button, label {
				color: RGB(255,255,255);
				font-family: "Arial", sans-serif;
			}
			.framed {
				background-color: RGB(0,0,0);
				border: 0.5vw solid RGB(255,255,255);
			}
			.framed.thin {
				border-width: 0.25vw;
			}
			#canvas {
				z-index: 0;
				height: 80vh;
				width: 80vh;
				position: fixed;
				top: 10vh;
				left: calc(50vw - 40vh);
			}
			#title {
				z-index: 0;
				height: auto;
				width: auto;
				position: fixed;
				top: 2vh;
				left: 5vw;
				text-align: left;
				font-size: 6vh;
			}
			#configuration {
				z-index: 0;
				height: calc(10vh - 1vw);
				width: 100vw;
				position: fixed;
				bottom: 0;
				left: 0;
				border-top: 0.5vw solid RGB(255,255,255);
			}
			button:hover, input:hover {
				background-color: RGB(64,64,64);
			}
			button:active, input:focus {
				background-color: RGB(32,32,32);
			}
			#configuration > button {
				z-index: 1;
				font-size: 2vw;
				width: 20%;
				height: 80%;
				position: absolute;
				top: 10%;
			}
			#openKeyBindings {
				right: 5%;
			}
			#openScoring {
				right: 30%;
			}
			#openVisuals {
				right: 55%;
			}
			.popup {
				z-index: 2;
				width: 90vh;
				height: 90vh;
				position: fixed;
				top: 5vh;
				left: calc(50vw - 45vh);
			}
			.popup > .popupContent {
				z-index: 2;
				width: 72vh;
				height: 72vh;
				position: absolute;
				top: 9vh;
				left: 9vh;
			}
			.popup * {
				z-index: 3;
			}
			.popup.disabled {
				display: none;
			}
			.popup.enabled {
				display: block;
			}
			.popupClose {
				width: 5%;
				height: 5%;
				position: absolute;
				top: 1.25%;
				left: 1.25%;
			}
			.popup.config > .popupContent {
				display: grid;
				grid-template: repeat(auto-fit, 5vh) / 51vh 11vh;
				grid-auto-flow: row;
				grid-gap: 4.5vh 10vh;
				place-items: stretch;
			}
			.popup.config > .popupContent > label, .popup.config > .popupContent > input, .popup.config > .popupContent > button:not(.popupClose) {
				font-size: 4.5vh;
				text-align: center;
			}
			.popup.config > .popupContent > label {
				text-align: left;
			}
			#errorMessage > h2, #errorMessage > p {
				color: RGB(255,0,0);
				margin-left: 5%;
				margin-right: 5%;
			}
			#errorMessageHeader {
				margin-top: 5%;
				margin-bottom: 2.5%;
			}
			#errorMessageBody {
				margin-top: 2.5%;
				margin-bottom: 5%;
			}
		</style>
	</head>
	<body>
		<h1 id="title">
			Pong
		</h1>
		<canvas class="framed" id="canvas">
		</canvas>
		<div id="configuration">
			<button class="framed thin" id="openKeyBindings">
				Key Bindings
			</button>
			<div class="popup config framed disabled" id="keyBindings">
				<button class="popupClose framed thin" id="closeKeyBindings">
					X
				</button>
				<div class="popupContent">
					<label for="keyPaddle0Up">
						Paddle 0 Up
					</label>
					<input type="text" readonly="true" class="framed thin" id="keyPaddle0Up">
					</input>
					<label for="keyPaddle0Down">
						Paddle 0 Down
					</label>
					<input type="text" readonly="true" class="framed thin" id="keyPaddle0Down">
					</input>
					<label for="keyPaddle1Up">
						Paddle 1 Up
					</label>
					<input type="text" readonly="true" class="framed thin" id="keyPaddle1Up">
					</input>
					<label for="keyPaddle1Down">
						Paddle 1 Down
					</label>
					<input type="text" readonly="true" class="framed thin" id="keyPaddle1Down">
					</input>
					<label for="keyClose">
						Close
					</label>
					<input type="text" readonly="true" class="framed thin" id="keyClose">
					</input>
				</div>
			</div>
			<button class="framed thin" id="openScoring">
				Scoring
			</button>
			<div class="popup config framed disabled" id="scoring">
				<button class="popupClose framed thin" id="closeScoring">
					X
				</button>
			</div>
			<button class="framed thin" id="openVisuals">
				Visuals
			</button>
			<div class="popup config framed disabled" id="visuals">
				<button class="popupClose framed thin" id="closeVisuals">
					X
				</button>
			</div>
		</div>
		<div class="popup framed disabled" id="errorMessage">
			<h2 id="errorMessageHeader">
				An Error Has Occurred:
			</h2>
			<p id="errorMessageBody">
			</p>
		</div>
	</body>
	<script>
		//<game & gui>
		//keyBindings, maxScore, and colors are configuration values
		//keyBindings = {paddle0Up, paddle0Down, paddle1Up, paddle1Down}
		var keyBindings = ["w", "s", "ArrowUp", "ArrowDown"];
		var maxScore = 6;
		//colors = {backgroundColor, paddle0Color, paddle1Color, ballColor}
		var colors = ["#000000", "#FFFFFF", "#FFFFFF", "#FFFFFF"];
		//defaultConfigurationValues = {keyBindings, maxScore, colors}
		var defaultConfigurationValues = [["w", "s", "ArrowUp", "ArrowDown"], 6, ["#000000", "#FFFFFF", "#FFFFFF", "#FFFFFF"]];
		//</game & gui>
		//<gui>
		var openKeyBindings = document.getElementById("openKeyBindings");
		var keyBindingsPopup = document.getElementById("keyBindings");
		var closeKeyBindings = document.getElementById("closeKeyBindings");
		openKeyBindings.addEventListener("click", function() {
			keyBindingsPopup.classList.remove("disabled");
			keyBindingsPopup.classList.add("enabled");
		});
		closeKeyBindings.addEventListener("click", function() {
			keyBindingsPopup.classList.remove("enabled");
			keyBindingsPopup.classList.add("disabled");
		});
		//</gui>
		//<game>
		var w = window.innerWidth;
		var h = window.innerHeight;
		var canvas = document.getElementById("canvas");
		canvas.width = w;
		canvas.height = h;
		var c = canvas.getContext("2d");
		c.fillStyle = colors[0];
		c.fillRect(0, 0, w, h);
		/*
		positionSize = {
			{
				{paddle0X, paddle0Y},
				{paddle0W, paddle0H}
			},
			{
				{paddle1X, paddle1Y},
				{paddle1W, paddle1H}
			},
			{
				{ballX, ballY},
				{ballW, ballH}
			}
		}
		*/
		var padding = w / 16;
		var ballR = w / 64;
		positionSize = [
			[
				[padding, (h / 2) - (w / 8)],
				[w / 32, w / 4]
			],
			[
				[w - padding - (w / 32), (h / 2) - (w / 8)],
				[w / 32, w / 4]
			],
			[
				[w / 2, h / 2],
				[2 * ballR, 2 * ballR]
			]
		];
		c.fillStyle = colors[1];
		c.fillRect(positionSize[0][0][0], positionSize[0][0][1], positionSize[0][1][0], positionSize[0][1][1]);
		c.fillStyle = colors[2];
		c.fillRect(positionSize[1][0][0], positionSize[1][0][1], positionSize[1][1][0], positionSize[1][1][1]);
		c.fillStyle = colors[3];
		c.arc(positionSize[2][0][0], positionSize[2][0][1], ballR, 0, 2 * Math.PI);
		/*
		textLabel("errorMessage", "An error has occurred:");
		hideElement("errorMessage");
		var errorH = 3 * w / 8;
		var errorW = w / 2;
		setSize("errorMessage", errorW, errorH);
		setPosition("errorMessage", w / 2 - errorW / 2, h / 2 - errorH / 2);
		setProperty("errorMessage", "background-color", "#000000");
		setProperty("errorMessage", "border-color", "#FFFFFF");
		setProperty("errorMessage", "border-width", w / 64);
		*/
		function moveObject(object, x, y, relativePositioning) {
			var objectType = 0;
			switch (object) {
				case 0:
				case 1:
					objectType = 0;
					break;
				case 2:
					objectType = 1;
					break;
				default:
					return undefined;
			};
			c.fillStyle = colors[0];
			//0.5 is added to w, h, and r to account for a "white-outline residue" that occurs
			if (objectType === 0) {
				c.fillRect(positionSize[object][0][0], positionSize[object][0][1], positionSize[object][1][0] + 0.5, positionSize[object][1][1] + 0.5);
			} else {
				//c.fillRect(positionSize[object][0][0] - (positionSize[object][1][0] / 2), positionSize[object][0][1] - (positionSize[object][1][1] / 2), positionSize[object][1][0], positionSize[object][1][1]);
				c.arc(positionSize[object][0][0], positionSize[object][0][1], positionSize[object][1][0] / 2 + 0.5, 0, 2 * Math.PI);
				c.fill();
			};
			if (relativePositioning) {
				positionSize[object][0][0] += x;
				positionSize[object][0][1] += y;
			} else {
				positionSize[object][0][0] = x;
				positionSize[object][0][1] = y;
			};
			c.fillStyle = colors[object + 1];
			if (objectType === 0) {
				c.fillRect(positionSize[object][0][0], positionSize[object][0][1], positionSize[object][1][0], positionSize[object][1][1]);
			} else {
				c.arc(positionSize[object][0][0], positionSize[object][0][1], positionSize[object][1][0] / 2, 0, 2 * Math.PI);
				c.fill();
			};
		};
		var paddleMovementLoop = [0, 0];
		function paddleMovement(paddle, state, direction) {
			window.clearInterval(paddleMovementLoop[paddle]);
			if (state) {
				paddleMovementLoop[paddle] = window.setInterval(function() {
					var d0 = ((h / 50) * direction);
					var d = positionSize[paddle][0][1] + d0
					if (d < 0) {
						d0 = -positionSize[paddle][0][1];
					} else if (d + positionSize[paddle][1][1] > h) {
						d0 = h - (positionSize[paddle][0][1] + positionSize[paddle][1][1]);
					};
					moveObject(paddle, 0, d0, true);
				}, 10);
			};
		};
		function errorHandling(errorObject) {
			/*
			setText("errorMessage", "errorMessage", "An error has occurred:\n" + errorObject.name + ": " + errorObject.message);
			showElement("errorMessage");
			*/
		};
		window.addEventListener("keydown", function(e) {
			console.log("keydown " + e.key);
			try {
				var key = e.key;
				switch (key) {
					case keyBindings[0]:
						console.log("0");
		  				paddleMovement(0, true, -1);
		  				break;
		  			case keyBindings[1]:
						console.log("1");
						paddleMovement(0, true, 1);
						break;
					case keyBindings[2]:
						console.log("2");
						paddleMovement(1, true, -1);
						break;
					case keyBindings[3]:
						console.log("3");
						paddleMovement(1, true, 1);
						break;
					default:
						console.log("d");
						break;
				};
			} catch (errorObject) {
				errorHandling(errorObject);
			};
		});
		window.addEventListener("keyup", function(e) {
			console.log("keyup " + e.key);
			try {
				var key = e.key;
				switch(key) {
					case keyBindings[0]:
						paddleMovement(0, false, -1);
						break;
					case keyBindings[1]:
						paddleMovement(0, false, 1);
						break;
					case keyBindings[2]:
						paddleMovement(1, false, -1);
						break;
					case keyBindings[3]:
						paddleMovement(1, false, 1);
						break;
					default:
						break;
				};
			} catch (errorObject) {
				errorHandling(errorObject);
		  };
		});
		//ballVelocity = {x vector, y vector, magnitude, direction (radian angle)}
		var ballVelocity = [0, 0, h / 200, Math.random() * 2 * Math.PI];
		ballVelocity[0] = ballVelocity[2] * Math.cos(ballVelocity[3]);
		ballVelocity[1] = ballVelocity[2] * Math.sin(ballVelocity[3]);
		var ballMovement = window.setInterval(function() {
			//Top edge or bottom edge
			if (positionSize[2][0][1] - positionSize[2][1][0] / 2 <= 0 || positionSize[2][0][1] + positionSize[2][1][0] / 2 >= h) {
				
			};
			//{Left edge, right edge}
			var horizontalEdgeCollisions = [positionSize[2][0][0] - positionSize[2][1][0] / 2 <= 0, positionSize[2][0][0] + positionSize[2][1][0] / 2 >= w];
			//Left edge or right edge
			if (horizontalEdgeCollisions[0] || horizontalEdgeCollisions[1]) {
				//Left edge
				if (horizontalEdgeCollisions[0]) {
				//Right edge
				} else {
					
				};
			};
			//{Paddle 0, paddle 1}
			var paddleCollisions = [];
			//Paddle 0 or paddle 1
			if (paddleCollision[0] || paddleCollision[1]) {
				//Paddle 0
				if (paddleCollisions[0]) {
				//Paddle 1	
				} else {
					
				};
			};
			moveObject(2, ballVelocity[0], ballVelocity[1], true);
		}, 10);
		//</game>
/*
(o_x, o_y): circle origin
r: Circle radius

(c_x, c_y): top-left corner of rectangle
w: rectangle width
h: rectangle height


Collision at a point (x, y) if:

sqrt(|o_x - x|^2 + |o_y - y|^2) <= r and (c_x <= x <= c_x + w and c_y <= y <= c_y + h)

o_x - r <= x <= o_x + r
c_x <= x <= c_x + w

a l  b
*----*
  *----*
  A L  B
(a <= A && a + l >= A) || A <= a <= A + L
(positionSize[2][0][0] - positionSize[2][1][0] / 2 <= positionSize[0][0][0] && positionSize[2][0][0] + positionSize[2][1][0] / 2 >= positionSize[0][0][0]) || (positionSize[0][0][0] <= positionSize[2][0][0] - positionSize[2][1][0] / 2 && positionSize[2][0][0] - positionSize[2][1][0] / 2 <= positionSize[0][0][0] + positionSize[0][1][0])


Collision at border:

o_x - r <= 0 || o_x + r >= w || o_y - r <= 0 || o_y + r >= h

Top:   o_y - r <= 0
Down:  o_y + r >= h
Left:  o_x - r <= 0
Right: o_x + r >= w

frictionAcceleration = frictionConstant * ballVelocityX * paddleVelocityDirection
//frictionConstant = coefficientOfFriction * ballM

On collision with paddle:

v_x *= -1;
v_x += frictionAcceleration in the same direction as the new, inverted v_x
v_y += frictionAcceleration

On collision with wall:
	Vertical:   x_y *= -1
	Horizontal: v_x *= -1

To-do: Add Play/Pause / running button
*Button is black when game is running and grey when it is paused
*/
	</script>
</html>
